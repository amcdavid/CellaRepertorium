---
title: "10X B cells BCR"
output: BiocStyle::md_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>")
```

```{r setup}
load_all()
#library(CellaRepertorium)
library(dplyr)
library(ggplot2)
library(readr)
library(tidyr)
library(stringr)
```

# Load B cell data set

```{r}
# If we haven't cloned the github repo we will need to download the data
if(!file.exists(data_path <- system.file('data', 'ccdb_bcell.rda', package = 'CellaRepertorium'))){
    data_path = 'ccdb_bcell.rda'
    download.file('https://github.com/amcdavid/CellaRepertorium/raw/master/data/ccdb_bcell.rda', destfile = data_path)
}
load(data_path)
cdb = ccdb_bcell
```

PBMC pooled from BALB/c and C57BL/6 mice [were assayed on 10X genomics V3 chemistry](https://support.10xgenomics.com/single-cell-vdj/datasets/3.0.0/vdj_v1_mm_c57bl6_pbmc_b) and a library enriched for B Cells were run. 

## Load 5' expression

5' expression was also generated

```{r}
cdb = canonicalize_cell(cdb, contig_fields = 'is_cell')
cdb = mutate_cdb(cdb, celltype = guess_celltype(chain))
cdb = filter_cdb(cdb,high_confidence)
```

After filtering for only high_confidence contigs there are `r nrow(cdb$contig_tbl)` contigs.

We annotate the contig as a alpha-beta T cell, gamma-delta T cell, B cell or chimeric "multi" cell type based on where various 

# High confidence UMIs belonging to T cells per cell

```{r}
total_umi = crosstab_by_celltype(cdb)

ggplot(total_umi, aes(color = factor(is_cell), x = B, group = interaction(is_cell, pop))) + stat_ecdf() + coord_cartesian(xlim = c(0, 10)) + ylab('Fraction of barcodes') + theme_minimal() + scale_color_discrete('10X called cell?')
```

10X defines [a procedure](https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/algorithms/cell-calling)  to separate cells from background that fits a Gaussian mixture model to the UMI distributions for each sample.  However in some cases, it may be desirable to implement a common QC threshold with a different stringency, such as:

*  Comparing across multiple samples
*  When a sample has been enriched for a particular cell type (eg with pre-sequencing flow cytometry).

When we consider only high confidence UMIs that unambiguous map to T cells, most "non cells" have 1 or fewer, while most putative cells have >5.  However, we might want to adopt a different UMI-based cell filter, as was done below.  Is there a way to evaluate a sensitivity/specificity in distinguishing cells from debris, or T cells from other cell types?

# Reads / UMIs

```{r}
qual_plot = ggplot(cdb$contig_tbl, aes(x = celltype, y= umis)) + geom_violin() + geom_jitter() + facet_wrap(~ pop) + scale_y_log10() + xlab("Annotated cell type")

qual_plot 
qual_plot + aes(y = reads)
```

The number of UMIs and reads by sample and annotated cell type.

# Apply T-cell contig UMI filter

```{r, results = 'asis'}
# At least 2 UMI mapping to high confidence T cell contigs.
good_bc = total_umi %>% ungroup() %>% filter(is_cell) %>% filter(B >= 2)
total_cells = good_bc %>% group_by(pop) %>% summarize(good_bc = n())
knitr::kable(total_cells)
```

And take only high confidence, full length, productive B cell contigs. Apply a filter on UMIs.

```{r}
cdb_qc =  filter_cdb(cdb, full_length, productive == 'True', high_confidence, chain != 'Multi', is_cell, str_length(cdr3_nt) > 10)
cdb_qc$cell_tbl = semi_join(cdb_qc$cell_tbl, good_bc)

cdb_qc = cdhit_ccdb(cdb_qc, sequence_key = 'cdr3_nt', type = 'DNA', identity = .9, min_length = 10)
cdb_qc = fine_clustering(cdb_qc, 'cdr3_nt', type = 'DNA')
cdb_qc = canonicalize_cluster(cdb_qc, representative = 'cdr3')

ggplot(cdb_qc$cluster_tbl %>% filter(n_cluster>1) %>% select(cluster_idx, chain, avg_distance, n_cluster) %>% gather(key, value, avg_distance, n_cluster), aes(x = value))+ facet_wrap(~key + chain, scales = 'free') + geom_histogram() + scale_y_sqrt()

```

```{r expanded_clones}
class_colors = tibble(chain =  unique(cdb_qc$cluster_tbl$chain)) %>% mutate(class_color =  RColorBrewer::brewer.pal(length(chain),"Set1")[seq_along(chain)])

cdb_qc$cluster_pk = 'representative'

whitelist = cdb_qc$cluster_tbl %>% filter(n_cluster > 5, chain == 'IGH') %>% dplyr::select(cluster_idx.1 = representative) %>% unique()

pairing_list = pairing_tables(cdb_qc, table_order = 2, orphan_level = 1, min_expansion = 5, cluster_whitelist = whitelist, cluster_keys = c('cdr3', 'representative', 'chain', 'v_gene', 'j_gene', 'avg_distance'))
```

```{r plot_expanded}
pairs_plt = ggplot(pairing_list$cell_tbl, aes(x = cluster_idx.1_fct, y = cluster_idx.2_fct, color = pop)) + geom_jitter(width = .2, height = .2) + theme_minimal() + xlab('Heavy') + ylab('Light')

feature_tbl = left_join(bind_rows(pairing_list$idx1_tbl, pairing_list$idx2_tbl), class_colors)

ylab = tibble(representative =  ggplot_build(pairs_plt)$layout$panel_params[[1]]$y.label) %>% left_join(feature_tbl) %>% mutate(class_color = ifelse(is.na(class_color), '#E41A1C', class_color))

xlab = tibble(representative =  ggplot_build(pairs_plt)$layout$panel_params[[1]]$x.label) %>% left_join(feature_tbl) %>% mutate(class_color = ifelse(is.na(class_color), '#E41A1C', class_color))

pairs_plt = pairs_plt + theme(axis.text.x = element_text(angle = 90, color = xlab$class_color, size = 8), axis.text.y = element_text(color = ylab$class_color, size = 8))

pairs_plt

```

