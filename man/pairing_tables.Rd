% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pairing-methods.R
\name{pairing_tables}
\alias{pairing_tables}
\title{Generate a list of tables representing clusters paired in cells}
\usage{
pairing_tables(cluster_tbl, cell_identifiers = "barcode",
  cluster_idx = "cluster_idx",
  canonicalize_fun = canonicalize_by_chain, table_order = 2,
  min_expansion = 2, orphan_level = 1, cluster_whitelist = NULL,
  cluster_blacklist = NULL, cell_tbl = NULL, feature_tbl = NULL)
}
\arguments{
\item{cluster_tbl}{a table with all combinations of clusters in all cells}

\item{cell_identifiers}{character vector naming fields that key a cell}

\item{cluster_idx}{character naming a single field IDing the clusters}

\item{canonicalize_fun}{a function with signature `canonicalize_fun(cluster_tbl, cell_identifiers, cluster_idx, order = i)` that for each `cell_identifier` returns a single contig that depends on the `order`.  For instance \link{canonicalize_by_prevalence} or \link{canonicalize_by_chain}.}

\item{table_order}{Integer larger than 1. What order of cluster_idx will be paired, eg, order = 2 means that the most common and second most common cluster_idx will be sought for each cell}

\item{min_expansion}{the minimal number of times a pairing needs to occur for it to be reported}

\item{orphan_level}{Integer larger than 0 and less than or equal to `table_order`.  Given that at least `min_expansion` cells are found that have `table_order` chains identical, how many `cluster_idx` pairs will we match on to select other cells.  Example: `ophan_level=1` means that cells that share just a single chain with the}

\item{cluster_whitelist}{a table of "cluster_idx" that should always be reported.  In contrast to the `cluster_tbl`, here the clusters must be named "cluster_idx.1", "cluster_idx.2" (if order-2 pairs are being selected).}

\item{cluster_blacklist}{a table of "cluster_idx" that will never be reported.  Must be named as per `cluster_whitelist`.}

\item{cell_tbl}{optional, ancillary table with additional cell features.  Must also be keyed by `cell_identifiers`}

\item{feature_tbl}{optional, ancillary table with additional cluster features.  Must also be keyed by `cluster_idx`}
}
\value{
list of tables.  The `cell_tbl` is keyed by the `cell_identifiers`, with fields "cluster_idx.1", "cluster_idx.2", etc, IDing the contigs present in each cell. "cluster_idx.1_fct" and "cluster_idx.2_fct" cast these fields to factors and are reordered to maximize the number of pairs along the diagonal. The `idx1_tbl` and `idx2_tbl` report information (passed in about the `cluster_idx` by `feature_tbl`.)  The `cluster_pair_tbl` reports all pairings found of contigs, and the number of times observed.
}
\description{
A contingency table of every combination of `cluster_idx` up to `table_order` is generated.
Combinations that are found in at least `min_expansion` number of cells are reported.  All cells that have these combinations are returned, as well as cells that only have `orphan_level` of matching `cluster_idx`.
}
\details{
For example, if `table_order=2` and `min_expansion=2` then heavy/light or alpha/beta pairs found two or more times will be returned (as well as alpha-alpha pairs, etc, if those are present).
If `orphan_level=1` then all cells that share just a single chain with an expanded clone will be returned.

The `cluster_idx.1_fct` and `cluster_idx.2_fct` fields in `cell_tbl`, `idx1_tbl`, `idx2_tbl` are cast to factors and ordered such that pairings will tend to occur along the diagonal when they are cross-tabulated.
This facilitates plotting.
}
\section{Caveats and warnings}{

 The cell_idx -> cluster_idx map is generally one-to-many, and is resolved by `canonicalize_fun`.  For `table_order>1`, few collisions are expected as most cells will contain no more than 2 clusters.  Any collisions are resolved by returning the most prevalent cluster, across samples.  When two clusters are tied for most prevalent within a cell, the `cluster_idx` returned is arbitrary. Therefore, when `table_order=1`, it is strongly recommended to subset the `cluster_tbl` to just a single chain.
}

\examples{
library(dplyr)
cluster_tbl = data_frame(clust_idx = gl(3, 2), cell_idx = rep(1:3, times = 2))
# no pairs found twice
pt1 = pairing_tables(cluster_tbl, 'cell_idx', 'clust_idx', canonicalize_by_prevalence)
# all pairs found, found once.
pt2 = pairing_tables(cluster_tbl, 'cell_idx', 'clust_idx',
    canonicalize_by_prevalence, min_expansion = 1)
pt2$cell_tbl
cluster_tbl2 = bind_rows(cluster_tbl, cluster_tbl \%>\% mutate(cell_idx = rep(4:6, times = 2)))
#all pairs found twice
pt3 = pairing_tables(cluster_tbl2, 'cell_idx', 'clust_idx', canonicalize_by_prevalence, min_expansion = 1)
pt3$cell_tbl
# `canonicalize_by_chain` expects fields `umis`, `reads`
# to break ties,  wrap the function to change this
cluster_tbl3 = cluster_tbl2 \%>\%
    mutate(umis = 1, reads = 1, chain = rep(c('TRA', 'TRB'), times = 6))
pt4 = pairing_tables(cluster_tbl3, 'cell_idx', 'clust_idx',
    canonicalize_by_chain, min_expansion = 1, table_order = 2)
}
\seealso{
canonicalize_by_prevalence, canonicalize_by_chain
}
